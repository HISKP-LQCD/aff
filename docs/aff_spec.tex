\documentclass[10pt,letterpaper]{article}


\usepackage{color}
\definecolor{darkblue}{cmyk}{1,1,0,0.7}
\usepackage[dvipdfm,colorlinks=true,linkcolor=darkblue]{hyperref}
\usepackage{graphicx}
\usepackage{makeidx}
\renewcommand{\indexname}{\section*{INDEX}\addcontentsline{toc}{section}{\protect{\numberline{}INDEX}}}
\makeindex
%\usepackage{amsmath}


\newcommand{\bc}{\begin{center}}
\newcommand{\ec}{\end{center}}
\newcommand{\bi}{\begin{itemize}}
\newcommand{\ei}{\end{itemize}}             % terms and definitions
\newcommand{\term}[1]{\textit{#1}}          %
\newcommand{\ctext}[1]{\texttt{#1}}         % c mono text
\newcommand{\cvar}[1]{\ctext{#1}}           % c variables(in func. prototypes, etc.)
\newcommand{\libname}[1]{\ctext{#1}\index{\ctext{#1}}} % lib names, with indexing
\newcommand{\ctype}[1]{\ctext{#1}}          % c type names, no indexing
\newcommand{\libtype}[1]{\libname{#1}}      % lib type names, with indexing
\newcommand{\NULL}{\ctext{NULL}}


\newcommand{\exblock}[1]{\par\texttt{#1}\par}
\newcommand{\example}[1]{\texttt{#1}}

%\newcommand{\Description}{{\textbf Description}\\}
%\newcommand{\Synopsis}{{\textbf Synopsis}\\}
%\newcommand{\RetValue}{{\textbf Return value}\\}
\def\FuncHead#1{\subsection{\libname{#1}}}
\def\Syn{\par\noindent{\bf Synopsis}\tt
  \everypar={\hangindent=64pt\hangafter=1
    \raggedright\hspace{16pt}}\par\noindent}
\def\Desc#1{\par\noindent{\bf Description}\par
  \hangindent=16pt\hangafter=0\noindent#1\par}
\def\RetVal#1{\par\noindent{\bf Return Value}\par
  \hangindent=16pt\hangafter=0\noindent#1\par}

\setcounter{tocdepth}{2}

\begin{document}
\centerline{\huge\bf AFF lattice data storage format}
\vspace{20pt}
\centerline{\it Andrew~V.~Pochinsky, Sergey~N.~Syritsyn}
\centerline{\it MIT CTP, Cambridge, MA}
\vspace{10pt}
\centerline{\today}
\vspace{20pt}

\noindent This document describes the AFF data storage format. 
The AFF is hierarchical data format, efficient both in space and access time 
for storage of multiple small amounts of data.

\newpage
\tableofcontents
\newpage

\section{Purpose of AFF}
Lattice calculations produce a lot of data. 
This data usually consists of enormous number of small pieces, for example, correlator values for
each operator, each momentum and each in/out state.
Present approach is to store each piece\footnote{As it is done by ADAT stripping utilities}
as text in a separate file which has a fully descriptive name. 

Although this is both convenient for analysis and accessible by a text editor, text format leads
to a significant space overhead. 
In addition, some file systems, like PVFS, work badly with
many small files, taking too much time to open a file. 
Storing all data in an XML file leads to even greater space overhead; extraction of a single
data item requires parsing and validating the whole XML file.

AFF data storage format is aimed to replace this data storage scheme. 
AFF organization is aimed at optimization of data random read access.
We suggest to store all data related to a configuration or to an ensemble of configurations in
the same file.
To navigate an AFF data file, we introduce the system of hierarchical keys.
Data is stored in platform-independent, binary form.
To assure the data validity, both data and service information is checked against stored
MD5 checksum.



\section{Suggested AFF usage}

We suggest replacing the output of ADAT strippers with an AFF file format. 
Complicated file names will be replaced with hierarchical key names. 
The actual set of key names must be convenient for both interactive use and 
scripts for automatic data processing.

Scripts will access the data in an AFF file through command line utilities which will get the
data from a file and output the required data in appropriate (e.g., text) form. C/C++ analysis
codes will access the data through the AFF library, which will return data in the form
appropriate for a given platform.

Interactive browsing and modification of an AFF file will be done through command-line utilities. 
These utilities will allow searching and printing the keys, printing data, merging files,
insertion of data, and deleting entries. Probably, conversion from XML to ADAT will be possible,
but only for XML files with unique keys.


\section{Platform-independent data}
Both data and service information is stored in platform-independent format. 
Information on bit size of numbers is written in the header of an AFF file.
All integer numbers are stored in big-endian form. 
Double precision numbers are stored in some format\footnote{Ask Andrew Pochinsky ; his cell
number is ...}; the bit length and the mantissa size is stored in the header and is sufficient
to restore a \ctype{double} number on a machine of any architecture. 
A complex number is stored as a sequence of two double precision numbers, first the real part,
and second the imaginary part.

\begin{table}[ht]
\label{tab:types}
\bc
\caption{Numeric data types}
\begin{tabular}{c|c|l} \hline
Type & Size, bytes & Comment \\ \hline
Void & 0 & Empty node \\
Char & 1 & String(array of chars) \\
Int32 & 4 & 32-bit integer \\
Int64 & 8 & 64-bit integer \\
Double & 8 & double precision real number \\
Complex & 16 & double precision complex number \\ \hline
\end{tabular}
\ec
\end{table}


\section{Data file organization}
An AFF file represents data organized as a tree structure. 
It starts at \term{root} key, which may have multiple subkeys. 
Each subkey of a given key must have a unique name. 

Each subkey may have data associated with it, which is an arbitrary length array of any
predefined elementary types.
Single number is represented as an array of length 1.
Possible data types are listed in tab.\ref{tab:types}

Access to any key and data associated with it is realized through a path created from
key names starting with root \example{/}:
\exblock{/key1/key2/.../keyN}


\section{Data file layout}

An AFF file has:
\bi
\item a header, describing the numeric storage format, tables and data position and checksums; 
it is placed in the beginning of the file
\item a symbol table, storing all key names;
\item a tree table, storing all nodes of key tree
\item a data section.
\ei

Each section may be located anywhere in a file. 
Their positions are stored in a header. 
Usually, a file starts with a header, then there is a data section, and symbol and tree tables 
are in the end of the file.

\subsection{Header}

\begin{table}[h]
\label{tab:header}
\bc
\caption{Header layout}
\begin{tabular}{|c|c|} \hline
Signature & ??? \\ \hline
Symbol table header & ??? \\ \hline
Tree header & ??? \\ \hline
Data header & ??? \\ \hline
Header MD5 sum & 16 \\ \hline
\end{tabular}
\ec
\end{table}

\begin{table}[h]
\label{tab:signature}
\bc
\caption{Signature layout}
\begin{tabular}{|c|c|} \hline
File version string, null-terminated &  21 ??? \\ \hline
Bits in Char & 1 \\ \hline
Bits in Double & 1 \\ \hline
Bits in Double mantissa & 1 \\ \hline
Exponents in Double & 4 \\ \hline
Header size in bytes & 4 \\ \hline
\end{tabular}
\ec
\end{table}


\subsection{Symbol table, tree, and data headers}

\begin{table}[h]
\label{tab:table_header}
\bc
\caption{Symbol table, tree, and data header layout}
\begin{tabular}{|c|c|} \hline
Offset  & 8 \\ \hline
Size in bytes & 8 \\ \hline
Section MD5 sum & 16 \\ \hline
\end{tabular}
\ec
\end{table}

\subsection{Symbol table}
Symbol table is a list of strings separated by a null char.

\subsection{Tree table}
Tree is represented by a table of entries. Each entry describes one node in a tree.

\begin{table}[h]
\label{tab:tree_entry}
\bc
\caption{Tree single entry layout}
\begin{tabular}{|c|c|} \hline
Type & 1 \\ \hline
Parent node Id & 8 \\ \hline
Node name Id (ref. to symbol table) & 4 \\ \hline
Size of stored array & 4 \\ \hline
Offset of stored data & 8 \\ \hline
\end{tabular}
\ec
\end{table}

\newpage


\section{AFF library interface}
AFF library is written in C and can be used by including the library header file ``lhpc-aff.h''. 
There is also lhpc-aff-config utility that allows one to obtain proper flags 
and libraries needed by AFF.
The library uses global names starting with aff in all case combinations. 
Not all such names may be described in the present specification.
It is illegal to rely on behavior of undescribed functions and types.

There are several opaque types which are used by the AFF library to access data:
\begin{table}
\caption{AFF interface opaque types.}
\label{tab:opaque_types}
\begin{tabular}{|c|c|} \hline
\libtype{AffWriter\_s} & A handler of an AFF file opened for writing \\ \hline
\libtype{AffReader\_s} & A handler of an AFF file opened for reading \\ \hline
\libtype{AffTree\_s} & A handler of an AFF tree \\ \hline
\libtype{AffNode\_s} & A handler of an AFF tree node \\ \hline
\libtype{AffSTable\_s} & A handler of an AFF symbol table \\ \hline
\libtype{AffSymbol\_s} & A symbol created and stored by the symbol table \\ \hline
\libtype{AffMD5\_s} & MD5 sum state \\ \hline
\libtype{AffNodeType\_e} & Type of the data stored in a node \\ \hline
\end{tabular}
\end{table}


\FuncHead{aff\_writer}
{\Syn struct~AffWriter\_s~*aff\_writer (const~char~*fname)\par}
\Desc{Allocate \libname{AffWriter\_s}, initialize it.
  Open a file for writing, initialize empty tables.
  If the file already exists, it is removed first.
  The right way to query status of \libname{aff\_writer} is to call
  \libname{aff\_writer\_errstr} on the result. 
  If \ctext{errstr()} returns \NULL, the object has been successfully
  created, otherwise \ctext{errstr()} returns a description of the error.
  Any pointer returned from \libname{aff\_writer} should be passed to 
  \libname{aff\_writer\_close} to free resources.
  }
\RetVal{Return a pointer to an \libname{AffWriter\_s}. The status must be checked by calling
  \libname{aff\_writer\_errstr}.}

\FuncHead{aff\_writer\_close}
{\Syn const~char~*aff\_writer\_close (struct~AffWriter\_s~*aff)\par}
\Desc{Finalize writing, calculate MD5 sums, write all service tables and header, 
  and close the file.}
\RetVal{Return \NULL on success, and a pointer to an error string on failure.}

\FuncHead{aff\_writer\_errstr}
{\Syn const~char~*aff\_writer\_errstr (struct~AffWriter\_s~*aff)\par}
\Desc{Return a pointer to an error string from the last fault.
  AFF implements latching errors: if an error occurs on a \libtype{AffWrtier\_s} object, 
  this object will signal errors on all subsequent calls. 
  The first error message is stored in the object and is accessible 
  via \libname{aff\_writer\_errstr} call.}
\RetVal{Return the string with the last error occurred, or \NULL if there were no errors.}

\FuncHead{aff\_writer\_stable}
{\Syn struct~AffSTable\_s~*aff\_writer\_stable (struct~AffWriter\_s~*aff)\par}
\Desc{Get the pointer the symbol table of the writer}
\RetVal{The pointer on success, or \NULL if \libname{AffWriter\_s} is not initialized.}

\FuncHead{aff\_writer\_tree}
{\Syn struct~AffTree\_s~*aff\_writer\_tree (struct~AffWriter\_s *aff)\par}
\Desc{Get the pointer to the tree table of the writer}
\RetVal{The pointer on success, or \NULL if \libname{AffWriter\_s} is not initialized.}
  
\FuncHead{aff\_writer\_root}
{\Syn struct~AffNode\_s~*aff\_writer\_root (struct~AffWriter\_s~*aff)\par}
\Desc{Get the handler to the root node. Any initialized writer always have a root node.}
\RetVal{The pointer on success, or \NULL if \libname{AffWriter\_s} is not initialized.}

\FuncHead{aff\_writer\_mkdir}
{\Syn struct~AffNode\_s~*aff\_writer\_mkdir (struct~AffWriter\_s~*aff, 
  struct~AffNode\_s~*dir, const~char~*name)\par}
\Desc{Create a new subkey \cvar{name} in the key node \cvar{dir} with type 
  \ctext{AffNodeVoid} (no associated data type). The type may be changed later.}
\RetVal{Return the pointer to the new key node on success, and \NULL on failures,
  i.e. \libname{AffWriter\_s} is not initialized, the name already exists, or not 
  enough memory.}




%\FuncHead{aff\_node\_put\_char}
%\Syn{int aff\_node\_put\_char(struct AffWriter\_s *aff, struct AffNode\_s *n, const char *d,
%  uint32\_t s)}
%\Desc{Put a char array \cvar{d} of size \cvar{s} into AFF file \cvar{aff}, 
%  in the key node \cvar{n}.}
%\RetVal{Return zero on success, and non-zero on failure}
%
%\FuncHead{aff\_node\_put\_int}
%\Syn{int aff\_node\_put\_int(struct AffWriter\_s *aff, struct AffNode\_s *n, 
%  const uint32\_t *d, uint32\_t s)}
%\Desc{Put an int32 array \cvar{d} of size \cvar{s} into AFF file \cvar{aff}, 
%  in the key node \cvar{n}.}
%\RetVal{Return zero on success, and non-zero on failure}

\FuncHead{aff\_node\_put\_{\it type}}
{\Syn int~aff\_node\_put\_char (struct~AffWriter\_s~*aff,
  struct~AffNode\_s~*n, const~char~*d, uint32\_t~s);

  int~aff\_node\_put\_int (struct~AffWriter\_s~*aff,
  struct~AffNode\_s~*n, const~uint32\_t~*d, uint32\_t~s);
  
  int~aff\_node\_put\_double (struct~AffWriter\_s~*aff, 
  struct~AffNode\_s~*n, const~double~*d, uint32\_t~s);
  
  int~aff\_node\_put\_complex (struct~AffWriter\_s~*aff, 
  struct~AffNode\_s~*n, const~double~\_Complex~*d, uint32\_t~s); \par
}
\Desc{Put an array \cvar{d} of {\it type} of size \cvar{s} into AFF file \cvar{aff} 
  in the key node \cvar{n}. Type may be \ctype{char}, \ctype{int}(32 bits), 
  \ctype{double} or \ctype{complex}.}
\RetVal{Return zero on success, and non-zero on failure.}
%put a complex array ``d'' of size ``s'' into AFF file ``aff'' key node ``n'';

\FuncHead{aff\_reader}
{\Syn struct~AffReader\_s~*aff\_reader (const~char~*file\_name);\par}
\Desc{Allocate \libname{AffWriter\_s}, initialize it. 
  Open a file for reading, read all tables. To check the status of \ctext{aff\_reader()}, 
  \libname{aff\_reader\_errstr} must be called. \ctext{errstr()} returns \NULL on success, 
  and the description of a problem otherwise. Any pointer returned by \ctext{aff\_reader()} 
  must be passed later to \libname{aff\_reader\_close} to free the resources.}
\RetVal{Return a pointer to \libname{AffWriter\_s}. The status must be checked by calling
  \libname{aff\_writer\_errstr}.}

\FuncHead{aff\_reader\_close}
{\Syn int~aff\_reader\_close (struct~AffReader\_s~*aff);\par}
\Desc{Close a file, deallocate \libname{AffReader\_s} and all its tables.}
\RetVal{Zero on success, non-zero on failure}

\FuncHead{aff\_reader\_errstr}
{\Syn const~char~*aff\_reader\_errstr (struct~AffReader\_s~*aff);\par}
\Desc{Get an error string from the last failure.}
\RetVal{Return a pointer to a string, or \NULL if no errors have occurred.}

\FuncHead{aff\_reader\_stable}
{\Syn struct~AffSTable\_s~*aff\_reader\_stable (const~struct~AffReader\_s~*aff);\par}
\Desc{Get the symbol table.}
\RetVal{Return a pointer to the symbol table, or \NULL if \cvar{aff} 
  is not initialized.}
  
\FuncHead{aff\_reader\_tree}
{\Syn struct~AffTree\_s~*aff\_reader\_tree (struct~AffReader\_s~*aff);\par}
\Desc{Get the tree table.}
\RetVal{Return a pointer to the symbol table, or \NULL if \cvar{aff} 
  is not initialized.}
  
\FuncHead{aff\_reader\_root}  
{\Syn struct~AffNode\_s~*aff\_reader\_root (struct~AffReader\_s~*aff);\par}
\Desc{Get the root node handler. Root node is always defined, even for empty tree.}
\RetVal{Return a pointer to the root node handler, or \NULL if \cvar{aff} 
  is not initialized.}
  
\FuncHead{aff\_reader\_chdir}
{\Syn struct~AffNode\_s~*aff\_reader\_chdir (struct~AffReader\_s~*aff, 
  struct~AffNode\_s~*dir, const~char~*name);\par}
\Desc{Get the handler to the subkey \cvar{name} in the key node \cvar{dir}.
  If the node does not exist, an error will be set in the \libname{AffReader\_s} object.}
\RetVal{Return a pointer to the handler or \NULL if it does not exist 
  or there is other failure.}

\FuncHead{aff\_node\_get\_{\it type}}
{\Syn int~aff\_node\_get\_char (const~struct~AffReader\_s~*aff, 
  const~struct~AffNode\_s~*n, char *d,~uint32\_t~s);\par
  int~aff\_node\_get\_int (const~struct~AffReader\_s~*aff, 
  const~struct~AffNode\_s~*n, int32\_t~*d, uint32\_t~s);\par
  int~aff\_node\_get\_double (const~struct~AffReader\_s~*aff, 
  const~struct~AffNode\_s~*n, double~*d, uint32\_t~s);\par
  int~aff\_node\_get\_complex (const~struct~AffReader\_s~*aff,
  const~struct~AffNode\_s~*n, double~\_Complex~*d, uint32\_t~s);\par}
\Desc{Get an array of {\it type} of size \cvar{s} from AFF file \cvar{aff} 
  in the key node \cvar{n} and store it to \cvar{d}. 
  Type may be \ctype{char}, \ctype{int}(32 bits),
  \ctype{double} or \ctype{complex}.
  If the data type does not match, an error will be set in the \libname{AffReader\_s} object.
  }
\RetVal{Return zero on success, and non-zero on failure.}


\section{AFF tree navigation}

\FuncHead{aff\_node\_foreach}
{\Syn void~aff\_node\_foreach (struct~AffNode\_s~*n,  
  void~(*proc)(struct~AffNode\_s~*child,  void~*arg),
  void~*arg);\par}
\Desc{Call function \cvar{proc} for each child of the node \cvar{n},
  and transfer \cvar{arg} as an argument. If \cvar{n} is \NULL, nothing is done.}

\FuncHead{aff\_node\_id}
{\Syn uint64\_t~aff\_node\_id (const~struct~AffNode\_s~*tn);\par}
\Desc{Get 64-bit node ID}
\RetVal{Return node ID. If \cvar{tn} is \NULL, return special value with all bits set.}

\FuncHead{aff\_node\_name}
{\Syn const~struct~AffSymbol\_s~*aff\_node\_name (const~struct~AffNode\_s~*n);\par}
\Desc{Get the key name associated with the node}
\RetVal{Return pointer to a string containing key name. The string 
  is internal to the reader(writer) and must not be freed. If \cvar{n} is \NULL,
  return \NULL.}

\FuncHead{aff\_node\_parent}
{\Syn struct AffNode\_s~*aff\_node\_parent (const~struct~AffNode\_s~*n);\par}
\Desc{Get the handler of node's parent. The parent of the root node is the root itself.}
\RetVal{Return the pointer to the handler of parent node. If \cvar{n} is \NULL, return \NULL.}

\FuncHead{aff\_node\_type}
{\Syn enum~AffNodeType\_e~aff\_node\_type (const~struct~AffNode\_s~*n);\par}
\Desc{Determine the type of data stored in node \cvar{n}.}
\RetVal{Return type of data. If \cvar{n} is zero, return \cvar{affNodeInvalid}.}

\FuncHead{aff\_node\_size}
{\Syn uint32\_t~aff\_node\_size (const~struct~AffNode\_s~*n);\par}
\Desc{Get the size of the data array stored in the node \cvar{n}.}
\RetVal{Return size of data in data type units. Return zero if \cvar{n} is \NULL.}

\FuncHead{aff\_node\_offset}
{\Syn uint64\_t~aff\_node\_offset (const~struct~AffNode\_s~*tn);\par}
\Desc{Get the 64-bit file offset of the stored data of node \cvar{tn}. }
\RetVal{Return the byte offset of data. Return zero if \cvar{tn} is \NULL.}

\FuncHead{aff\_node\_assign}
{\Syn int~aff\_node\_assign (struct~AffNode\_s~*node,
  enum~AffNodeType\_e~type, uint32\_t~size, uint64\_t~offset);\par}
\Desc{Assign type to the node \cvar{node}. This function is internal and should not
  be called by a user.}
\RetVal{Return zero on success, and non-zero on failure.}

\FuncHead{aff\_node\_{\it chdir}}
{\Syn struct~AffNode\_s~*aff\_node\_chdir (struct~AffTree\_s~*tree,
  struct~AffSTable\_s~*stable, struct~AffNode\_s~*n, int~create,
  const~char~*p);\par
  struct~AffNode\_s~*aff\_node\_cda (struct~AffTree\_s~*tree,
  struct~AffSTable\_s~*stable, struct~AffNode\_s~*n, int~create,
  const~char~*p[]);\par
  struct~AffNode\_s~*aff\_node\_cdv (struct~AffTree\_s~*tree,
  struct~AffSTable\_s~*stable, struct~AffNode\_s~*n, int~create,
  va\_list~va);\par
  struct~AffNode\_s~*aff\_node\_cd (struct~AffTree\_s~*tree,
  struct~AffSTable\_s~*stable, struct~AffNode\_s~*n, int~create, ...);\par
}
\Desc{aff\_node\_chdir returns the subkey of node \cvar{n} in the \cvar{tree} 
  with name \cvar{p}. aff\_node\_cda, aff\_node\_cdv, aff\_node\_cd descend the tree
  into subkeys with names transferred as \NULL-terminated array, va\_list 
  and \NULL-terminated argument list. If \cvar{create} is non-zero, all absent directories are
  created.}
\RetVal{Returns the handler of the target key on success. Returns \NULL if the target key is
  absent and \cvar{create} is zero, or attempt to create keys failed.}


\section{AFF tree data structure}

\FuncHead{aff\_tree\_init}
{\Syn struct~AffTree\_s~*aff\_tree\_init (void);\par}
\Desc{Allocate and initialize an AFF tree structure with only one node,
  which is root. The name of the root is an empty string ``''.}
\RetVal{Return a pointer to a new AFF tree, or \NULL if allocation failed.}

\FuncHead{aff\_tree\_fini}
{\Syn void~*aff\_tree\_fini (struct~AffTree\_s~*tree);\par}
\Desc{Free AFF data structure.}
\RetVal{Return \NULL. This helps with the following programming pattern:\\
  \ctext{tree\ =\ aff\_free\_fini(tree);}\\
  -- clean up the tree and guard stray accesses by setting it to \NULL.}

\FuncHead{aff\_tree\_foreach}
{\Syn void~aff\_tree\_foreach (const~struct~AffTree\_s~*tree,
  void~(*proc)(struct~AffNode\_s~*node, void~*arg), void~*arg);\par}
\Desc{Call function \cvar{proc} for each node of the tree in order of their ID numbers
  and pass \cvar{arg} as the argument. If \cvar{tree} is \NULL, nothing is done.}

\FuncHead{aff\_tree\_print}
{\Syn void~aff\_tree\_print (struct~AffTree\_s~*tree);\par}
\Desc{Print AFF tree for debug.}

\FuncHead{aff\_tree\_root}
{\Syn struct~AffNode\_s~*aff\_tree\_root (const~struct~AffTree\_s~*tree);\par}
\Desc{Get the root of the \cvar{tree}. A root is always present.}
\RetVal{Return a pointer to the root handler, or \NULL if \cvar{tree} is \NULL.}

\FuncHead{aff\_tree\_lookup}
{\Syn struct~AffNode\_s~*aff\_tree\_lookup (const~struct~AffTree\_s~*tree,
  const~struct~AffNode\_s~*parent, const~struct~AffSymbol\_s~*name);\par}
\Desc{Find the child of node \cvar{parent} with name \cvar{name}.}
\RetVal{Return a pointer to the child node handler, or \NULL if \cvar{tree} is \NULL
  or no such child is found.}

\FuncHead{aff\_tree\_index}
{\Syn struct~AffNode\_s~*aff\_tree\_index (const~struct~AffTree\_s~*tree,
  uint64\_t~index);\par}
\Desc{Get the node handler by its index. The index starts from zero, which is 
  reserved for the root node.}
\RetVal{Return a pointer to the node handler, or \NULL if \cvar{tree} is \NULL
  or no such node is found.}

\FuncHead{aff\_tree\_insert}
{\Syn struct~AffNode\_s~*aff\_tree\_insert (struct~AffTree\_s~*tree,
  struct~AffNode\_s~*parent, const~struct~AffSymbol\_s~*name);\par}
\Desc{Insert a child with name \cvar{name} to the node \cvar{parent}.}
\RetVal{Return a pointer to the new child node handler, or \NULL if such 
  node have already been present, \cvar{tree} is \NULL or the insertion failed.}

%\FuncHead{aff\_tree\_size}
%{\Syn uint64\_t~aff\_tree\_size (const~struct~AffTree\_s~*tn);\par}
%\Desc{Get the number of nodes, except the root.}
%\RetVal{Return the number of nodes except the root, or zero if \cvar{tn} is \NULL.}
%
%\FuncHead{aff\_tree\_file\_size}
%{\Syn uint64\_t~aff\_tree\_file\_size (const~struct~AffTree\_s~*tn);\par}
%\Desc{Get the size taken by the tree in an AFF file.}
%\RetVal{Return the size in bytes, or zero if \cvar{tn} is \NULL}
%

\section{AFF symbol table}

\FuncHead{aff\_stable\_init}
{\Syn struct~AffSTable\_s~*aff\_stable\_init (void);\par}
\Desc{Allocate and initialize an empty symbol table.}
\RetVal{Return a pointer to a new symbol table, or \NULL on failure.}

\FuncHead{aff\_stable\_fini}
{\Syn void~*aff\_stable\_fini (struct~AffSTable\_s~*st);\par}
\Desc{Free a symbol table.}

\FuncHead{aff\_stable\_print}
{\Syn void~aff\_stable\_print (const~struct~AffSTable\_s~*st);\par}
\Desc{Print symbol table for debug.}

\FuncHead{aff\_stable\_lookup}
{\Syn const~struct~AffSymbol\_s~*aff\_stable\_lookup (const~struct~AffSTable\_s~*st,
  const~char~*name);\par}
\Desc{Lookup a symbol in the table by its string name}
\RetVal{Return a pointer to symbol, or \NULL if there is no such symbol or
  \cvar{st} is zero.}

\FuncHead{aff\_stable\_index}
{\Syn const~struct~AffSymbol\_s~*aff\_stable\_index (const struct~AffSTable\_s~*st,
  uint32\_t~index);\par}
\Desc{Lookup a symbol in the table by its index. The index starts from zero.}
\RetVal{Return a pointer to the symbol, or \NULL if there is no such symbol or
  \cvar{st} is zero.}

\FuncHead{aff\_stable\_insert}
{\Syn const~struct~AffSymbol\_s~*aff\_stable\_insert (struct~AffSTable\_s~*st,
  const~char~*name);\par}
\Desc{Insert a new string into the symbol table. The string is duplicated insise.}
\RetVal{Return a pointer to the new symbol, or a pointer to the symbol with the same string
inserted before. Return \NULL if \cvar{st} is \NULL.}

%\FuncHead{aff\_stable\_size}
%{\Syn uint32\_t~aff\_stable\_size (const~struct~AffSTable\_s~*st);\par}
%\Desc{Get the number of symbols in the symbol table \cvar{st}.}
%\RetVal{Return the number of symbols in \cvar{st}, or zero if \cvar{st} is \NULL.}
%
%\FuncHead{aff\_stable\_file\_size}
%{\Syn uint64\_t~aff\_stable\_file\_size (const~struct~AffSTable\_s~*st);\par}
%\Desc{Get the size of symbol table if it is placed into AFF file.}
%\RetVal{Return the size in bytes, or zero if \cvar{st} is \NULL.}

\FuncHead{aff\_stable\_foreach}
{\Syn void~aff\_stable\_foreach (const~struct~AffSTable\_s~*st,
  void~(*proc)(const~struct~AffSymbol\_s~*sym, void~*arg), void~*arg);\par}
\Desc{Call the function \cvar{proc} for each symbol in the table in order of their 
  index passing \cvar{arg} as an argument. If \cvar{st} is zero, nothing is done.}

\FuncHead{aff\_symbol\_name}
{\Syn const~char~*aff\_symbol\_name (const~struct~AffSymbol\_s~*sym);\par}
\Desc{Get the name of the symbol. The string is stored internally in the symbol table
  and should not be freed or modified.}
\RetVal{Return a pointer to the null-terminated string, or \NULL if \cvar{sym} is \NULL.}

\FuncHead{aff\_symbol\_id}
{\Syn uint32\_t~aff\_symbol\_id (const~struct~AffSymbol\_s~*sym);\par}
\Desc{Get the index of a symbol.}
\RetVal{Return the index, or 0xffffffff if \cvar{sym} is zero.}

\section{Treap data structure implementation}

Manage treap data structure. \ctype{AffTreap\_s} is an opaque handler of a treap data structure.

\FuncHead{aff\_treap\_init}
{\Syn struct~AffTreap\_s~*aff\_treap\_init (void);\par}
\Desc{Allocate and initialize an empty treap.}
\RetVal{Return a pointer to a treap, or \NULL on failure.}

\FuncHead{aff\_treap\_fini}
{\Syn void~*aff\_treap\_fini (struct~AffTreap\_s~*h);\par}
\Desc{Free a treap.}

\FuncHead{aff\_treap\_cmp}
{\Syn int~aff\_treap\_cmp (const~void~*a\_ptr, unsigned~int~a\_size,
  const~void~*b\_ptr, unsigned~int~b\_size);\par}
\Desc{Compare key \cvar{a\_ptr} of length \cvar{a\_size} 
  with key \cvar{b\_ptr} of length \cvar{b\_size}. 
  This function defines the ordering used by
  the treap internaly. It is probably of little use to the user.}
\RetVal{Return -1 if key \cvar{a\_ptr} is less than \cvar{b\_ptr}, 
  +1 if key \cvar{a\_ptr} is greater than \cvar{b\_ptr},
  and zero if they are equal.}

\FuncHead{aff\_treap\_lookup}
{\Syn void~*aff\_treap\_lookup (const~struct~AffTreap\_s~*h,
  const~void~*key, int~ksize);\par}
\Desc{Lookup the the key \cvar{key} of length \cvar{ksize} in the treap \cvar{h}.}
\RetVal{Return the pointer to the data associated with the \cvar{key}, 
  or \NULL if there is no such key or \cvar{h} is \NULL.}

\FuncHead{aff\_treap\_insert}
{\Syn int~aff\_treap\_insert (struct~AffTreap\_s~*h,
  const~void~*key, int~ksize, void~*data);\par}
\Desc{Insert the pair \cvar{key} and \cvar{data} into the treap \cvar{h}. 
  Key must be unique.}
\RetVal{Return zero on successful insertion, or non-zero if the key is already present in the
  treap, insertion failed, or \cvar{h} is \NULL.}

\FuncHead{aff\_treap\_print}
{\Syn void~aff\_treap\_print (struct~AffTreap\_s~*h, 
  int~(*get\_vsize)(const~void~*));\par}
\Desc{Print the treap for debug.}


\section{MD5 sum functions}

\FuncHead{aff\_md5\_init}
{\Syn void~aff\_md5\_init (struct~AffMD5\_s~*);}
\Desc{Initialize MD5 sum state.}

\FuncHead{aff\_md5\_update}
{\Syn void~aff\_md5\_update (struct AffMD5\_s~*, const~uint8\_t~*, uint32\_t);}
\Desc{Update MD5 state when new data is added to a buffer.}

\FuncHead{aff\_md5\_update}
{\Syn void~aff\_md5\_final (uint8\_t~[16], struct~AffMD5\_s~*);}
\Desc{Produce the final value of MD5 sum.}

%features:
%  md5 checksum
%  portable, platform independent format
%  quick browsing, quick access to any stored data, without reading the whole file
%  operations: browsing, copy, merge, delete, formatted output
%  ?? how to change manually
%  ?? conversion from XML ONLY if all subkeys are unique
%  
%type table
%aff access interface
%  opaque types
%  open/close
%  put/get
%  insert node
%  ?? delete node
%suggested procedure:
%  strippers output an Aff file
%  analysis scripts access aff through command line
%  c/c++ code accesses through library
%motivation: slow access, enormous number of separate files by strippers
%
%
%
%FORMAT
%data (number) storage formats
%header formats
%
%header

%\section*{Index}

\printindex



\end{document}
